# Simulation for "Propensity score analysis with survey weighted data"
#    modified from the simulation from Dugoff et al 2014 from
#    http://onlinelibrary.wiley.com/doi/10.1111/1475-6773.12090/suppinfo

# Required R packages
require(survey)
require(doParallel)
require(foreach)
require(xtable)

# set up to run on three cores
cl <- makeCluster(3)
registerDoParallel(cl)

generate_sample <- function(void)
{ 
   pop_split <- split(data, data$stratum)
   
   draw_sample <- function(n, data)
   {
   data$s.wt <- data$s.wt * 30000 / n
   data[sample((1:nrow(data)), n, prob = data$prob_sel),]
   }
   
   samples <- do.call("rbind", mapply(draw_sample, 
         n = c(4000, 3000, 2000),
         data = pop_split, SIMPLIFY = FALSE))
   return(samples)
}

fit_model <- function(formula, design, var)
{
   fit <- svyglm(formula, design)
   index <- names(coef(fit)) == var
   return( as.numeric(c(coef(fit)[index], 
                        sqrt(diag(vcov(fit))[index]))) )
}

########################################################
## Generate data
########################################################
N <- 90000 # Population Size
stratum <- c(rep(1,30000), rep(2, 30000), rep(3,30000))
X <- c(rnorm(N/3, mean=-.25), rnorm(N/3, mean=0), rnorm(N/3, mean= .25))

results <- vector("list",5)

for(scenario in 1:5)
{
   set.seed(06182001)
   cat("Scenario",scenario,"\n")

   # Treatment model (has to be done in population to define PATT)
   tau0 <- -2
   tau1 <- log(4)
   if(scenario %in% 1:4)
      prob.t <- 1/(1+exp(-(1+tau0+tau1*X)))
   if(scenario == 5)
      prob.t <- 1/(1+exp(-(1+tau0+tau1*X^2)))
   treat <- rbinom(N, 1, prob.t)

   # Selection model
   beta0 <- -3.8
   beta1 <- -log(4)
   if(scenario %in% c(1,4,5))
      prob.sel <- 1/(1 + exp(-(1+beta0+beta1*X)))
   if(scenario==2)
      prob.sel <- 1/(1 + exp(-(1+beta0+beta1*0)))
   if(scenario==3)
      prob.sel <- 1/(1 + exp(-(1+beta0+(beta1/2)*treat + (beta1/2) * X)))
   S.WT <- 1/prob.sel

   if(scenario==4) # Rescaling of weights for controls
      S.WT[treat == 0] <- S.WT[treat == 0] * 1.3

   # Generate potential outcomes
   alpha0 <- 1
   alpha1 <- 1
   Y0 <- alpha0 + alpha1*X + rnorm(N, mean=0, sd=.5)

   gamma1 <- 0.2
   gamma2 <- 0.1   
   Y1 <- Y0 + gamma1 + gamma2*X + rnorm(N, mean=0, sd=.5)
   Y <- ifelse(treat==1, Y1, Y0) # Observed outcome

   # Final simulated data
   data <- data.frame(x=X,stratum=stratum,y0=Y0, y1=Y1, t=treat, y=Y, s.wt=S.WT)

   data$prob_sel <- prob.sel

   ########################################################
   ## Estimate Treatment Effects
   ########################################################

   # TRUTH
   ate <- mean(Y1)-mean(Y0)
   att <- mean(Y1[treat==1])-mean(Y0[treat==1])

   results[[scenario]]$ate <- ate
   results[[scenario]]$att <- att

   n.reps <- 10000
   # run in parallel (number of cores set up earlier)
   ests.list <-
   foreach(i.rep=1:n.reps,.packages=c("survey")) %dopar%
   {
      print(paste(scenario,"-",i.rep))
      samp <- generate_sample()

      # NAIVE
      temp     <- summary(lm(y ~ t + x, data=samp))
      # (0) not included in paper
      naive    <- coef(temp)["t","Estimate"]  
      naive_sd <- coef(temp)["t","Std. Error"]

      coverage_naive_ate <- 
         ifelse(naive-2*naive_sd < ate & naive +2*naive_sd > ate, 1, 0)
      coverage_naive_att <- 
         ifelse(naive-2*naive_sd < att & naive +2*naive_sd > att, 1, 0)

      naive_smd <- diff(tapply(samp$x, samp$t, mean)) / sd(samp$x)
      # (1) SMD
      survey_naive_smd <- diff(tapply(samp$x * samp$s.wt, samp$t, sum)/ 
                               tapply(samp$s.wt, samp$t, sum))/ sd(samp$x)

      # SURVEY NAIVE
      svy.design <- svydesign(ids=~1, strata=~stratum, weights=~s.wt, data=samp)
      lm.survey  <- fit_model(y ~ x + t, svy.design, var = "t")
      # (1) ATE/ATT
      survey_naive    <- lm.survey[1]
      survey_naive_sd <- lm.survey[2]

      coverage_survey_naive_ate <- 
         ifelse(survey_naive-2*survey_naive_sd < ate & 
                survey_naive+2*survey_naive_sd > ate, 1, 0)
      coverage_survey_naive_att <- 
         ifelse(survey_naive-2*survey_naive_sd < att &  
                survey_naive+2*survey_naive_sd > att, 1, 0)

      # (5) ATE/ATT
      lm.survey         <- fit_model(y ~ t, svy.design, var = "t")
      survey_naive_t    <- lm.survey[1]
      survey_naive_sd_t <- lm.survey[2]

      # PROPENSITY SCORE
      t.model <- glm(t ~ x, data=samp, family="binomial")
      pscore  <- predict(t.model, data=samp, type="response")

      samp$ate.wt <- ifelse(samp$t==1, 1/pscore, 1/(1-pscore))
      samp$att.wt <- ifelse(samp$t==1, 1,        pscore/(1-pscore))   
      # (2) SMD
      ps_ate_smd <- diff(tapply(samp$x * samp$s.wt * samp$ate.wt, samp$t, sum)/ 
                         tapply(samp$s.wt* samp$ate.wt, samp$t, sum))/ sd(samp$x)
      ps_att_smd <- diff(tapply(samp$x * samp$s.wt * samp$att.wt, samp$t, sum)/ 
                         tapply(samp$s.wt* samp$att.wt, samp$t, sum))/ sd(samp$x)
      
      tate.design <- svydesign(ids=~1, strata=~stratum, weights=~ate.wt, data=samp)
      
      lm.t <- fit_model(y ~ x + t, tate.design, var = "t")
      # (0) ATE not included in paper
      atewt    <- lm.t[1]
      atewt_sd <- lm.t[2]
      atewt_coverage <- ifelse(atewt-2*atewt_sd < ate & 
                               atewt+2*atewt_sd > ate, 1, 0)  
   
      tatt.design <- svydesign(ids=~1,          strata=~stratum, 
                               weights=~att.wt, data=samp)
      lm.t <- fit_model(y ~ x + t, tatt.design, var = "t")
      # (0) ATT not included in paper
      attwt    <- lm.t[1]
      attwt_sd <- lm.t[2]
      attwt_coverage <- ifelse(attwt-2*attwt_sd < att & 
                               attwt+2*attwt_sd > att, 1, 0)  

      samp$comb.ate <- samp$ate.wt*samp$s.wt
      comb.ate.design <- svydesign(ids=~1,            strata=~stratum, 
                                   weights=~comb.ate, data=samp)

      lm.comb <- fit_model(y ~ t + x, comb.ate.design, "t")
      # (2) ATE
      atewt_surv    <- lm.comb[1]
      atewt_surv_sd <- lm.comb[2]
      atewt_surv_coverage <- ifelse(atewt_surv-2*atewt_surv_sd < ate & 
                                    atewt_surv+2*atewt_surv_sd > ate, 1, 0)

      lm.comb <- fit_model(y ~ t, comb.ate.design, "t")
      # (6) ATE 
      atewt_surv_t    <- lm.comb[1]
      atewt_surv_sd_t <- lm.comb[2]

      samp$comb.att   <- samp$att.wt*samp$s.wt
      comb.att.design <- svydesign(ids=~1,            strata=~stratum, 
                                   weights=~comb.att, data=samp)
      lm.comb <- fit_model(y ~ t + x, comb.att.design, "t")
      # (2) ATT
      attwt_surv    <- lm.comb[1]
      attwt_surv_sd <- lm.comb[2]
      attwt_surv_coverage <- ifelse(attwt_surv-2*attwt_surv_sd < att & 
                                    attwt_surv+2*attwt_surv_sd > att, 1, 0)
   
      lm.comb <- fit_model(y ~ t, comb.att.design, "t")
      # (6) ATT 
      attwt_surv_t    <- lm.comb[1]
      attwt_surv_sd_t <- lm.comb[2]
   
      # use the sampling weight as a covariate
      #    when S depends on T, often this model separates 0s and 1s
      t.model <- glm(t ~ x + s.wt, data=samp, family="binomial", maxit=100)
      pscore  <- predict(t.model, data=samp, type="response")
   
      samp$ate.wt <- ifelse(samp$t==1, 1/pscore, 1/(1-pscore))
      samp$att.wt <- ifelse(samp$t==1, 1,        pscore/(1-pscore))   
      # (3) SMD
      ps_ate_sw_smd <- 
         diff(tapply(samp$x * samp$s.wt * samp$ate.wt, samp$t, sum)/ 
              tapply(samp$s.wt* samp$ate.wt, samp$t, sum))/ 
              sd(samp$x)
      ps_att_sw_smd <- 
         diff(tapply(samp$x * samp$s.wt * samp$att.wt, samp$t, sum)/ 
              tapply(samp$s.wt* samp$att.wt, samp$t, sum))/ 
              sd(samp$x)
   
      samp$comb.ate <- samp$ate.wt*samp$s.wt
      comb.ate.design <- svydesign(ids=~1,            strata=~stratum, 
                                   weights=~comb.ate, data=samp)

      lm.comb <- fit_model(y ~ t + x, comb.ate.design, "t")
      # (3) ATE 
      atewt_sw_surv    <- lm.comb[1]
      atewt_sw_surv_sd <- lm.comb[2]
      atewt_sw_surv_coverage <- 
         ifelse(atewt_sw_surv-2*atewt_sw_surv_sd < ate & 
                atewt_sw_surv+2*atewt_sw_surv_sd > ate, 1, 0)  
      lm.comb <- fit_model(y ~ t, comb.ate.design, "t")
      # (7) ATE 
      atewt_sw_surv_t    <- lm.comb[1]
      atewt_sw_surv_sd_t <- lm.comb[2]

      samp$comb.att <- samp$att.wt*samp$s.wt
      comb.att.design <- svydesign(ids=~1,            strata=~stratum, 
                                   weights=~comb.att, data=samp)
      lm.comb <- fit_model(y ~ t + x, comb.att.design, "t")
      # (3) ATT
      attwt_sw_surv    <- lm.comb[1]
      attwt_sw_surv_sd <- lm.comb[2]
      attwt_sw_surv_coverage <- 
         ifelse(attwt_sw_surv-2*attwt_sw_surv_sd < att & 
                attwt_sw_surv+2*attwt_sw_surv_sd > att, 1, 0)  

      lm.comb <- fit_model(y ~ t, comb.att.design, "t")
      # (7) ATT 
      attwt_sw_surv_t    <- lm.comb[1]
      attwt_sw_surv_sd_t <- lm.comb[2]

      # PS-WEIGHTED 
      t.model <- svyglm(t ~ x, svy.design, family="quasibinomial")
      pscore <- predict(t.model, data=samp, type="response")

      samp$ate.wt <- ifelse(samp$t==1, 1/pscore, 1/(1-pscore))
      samp$att.wt <- ifelse(samp$t==1, 1,        pscore/(1-pscore))   

      # (4) SMD
      survey_ps_ate_smd <- 
         diff(tapply(samp$x * samp$s.wt * samp$ate.wt, samp$t, sum)/ 
              tapply(samp$s.wt* samp$ate.wt, samp$t, sum))/ 
              sd(samp$x)
      survey_ps_att_smd <- 
         diff(tapply(samp$x * samp$s.wt * samp$att.wt, samp$t, sum)/ 
              tapply(samp$s.wt* samp$att.wt, samp$t, sum))/ 
              sd(samp$x)

      samp$comb.ate <- samp$ate.wt*samp$s.wt
      comb.ate.design <- svydesign(ids=~1,            strata=~stratum, 
                                   weights=~comb.ate, data=samp)

      lm.comb <- fit_model(y ~ t + x, comb.ate.design, "t")
      # (4) ATE 
      atewt_ps_surv    <- lm.comb[1]
      atewt_ps_surv_sd <- lm.comb[2]
      atewt_ps_surv_coverage <- 
         ifelse(atewt_ps_surv-2*atewt_ps_surv_sd < ate & 
                atewt_ps_surv+2*atewt_ps_surv_sd > ate, 1, 0)  

      lm.comb <- fit_model(y ~ t, comb.ate.design, "t")
      # (8) ATE 
      atewt_ps_surv_t    <- lm.comb[1]
      atewt_ps_surv_sd_t <- lm.comb[2]

      samp$comb.att <- samp$att.wt*samp$s.wt
      comb.att.design <- svydesign(ids=~1,            strata=~stratum, 
                                   weights=~comb.att, data=samp)
      lm.comb <- fit_model(y ~ t + x, comb.att.design, "t")
      # (4) ATT
      attwt_ps_surv    <- lm.comb[1]
      attwt_ps_surv_sd <- lm.comb[2]
      attwt_ps_surv_coverage <- 
         ifelse(attwt_ps_surv-2*attwt_ps_surv_sd < att & 
                attwt_ps_surv+2*attwt_ps_surv_sd > att, 1, 0)  

      lm.comb <- fit_model(y ~ t, comb.att.design, "t")
      # (8) ATT
      attwt_ps_surv_t    <- lm.comb[1]
      attwt_ps_surv_sd_t <- lm.comb[2]
   
      a <- c(naive = naive,                      # (x) is the row in results table 
             survey_naive = survey_naive,        # (1)
             survey_naive_t = survey_naive_t,    # (5)
             atewt = atewt,                           
             attwt = attwt,                           
             atewt_surv = atewt_surv,            # (2)
             attwt_surv = attwt_surv,            # (2)
             atewt_ps_surv = atewt_ps_surv,      # (4)
             attwt_ps_surv = attwt_ps_surv,      # (4)
             atewt_sw_surv = atewt_sw_surv,      # (3)
             attwt_sw_surv = attwt_sw_surv,      # (3)
             atewt_surv_t = atewt_surv_t,        # (6)
             attwt_surv_t = attwt_surv_t,        # (6)
             atewt_sw_surv_t = atewt_sw_surv_t,  # (7)
             attwt_sw_surv_t = attwt_sw_surv_t,  # (7)
             atewt_ps_surv_t = atewt_ps_surv_t,  # (8)
             attwt_ps_surv_t = attwt_ps_surv_t,  # (8)
             coverage_naive_ate = coverage_naive_ate, 
             coverage_naive_att = coverage_naive_att, 
             coverage_survey_naive_ate = coverage_survey_naive_ate,
             coverage_survey_naive_att = coverage_survey_naive_att,
             atewt_coverage = atewt_coverage,
             attwt_coverage = attwt_coverage,
             atewt_surv_coverage = atewt_surv_coverage,
             attwt_surv_coverage = attwt_surv_coverage,
             atewt_ps_surv_coverage = atewt_ps_surv_coverage,
             attwt_ps_surv_coverage = attwt_ps_surv_coverage,
             atewt_sw_surv_coverage = atewt_sw_surv_coverage,
             attwt_sw_surv_coverage = attwt_sw_surv_coverage,
             naive_smd = naive_smd, 
             survey_naive_smd = survey_naive_smd,
             ps_ate_smd = ps_ate_smd,
             ps_att_smd = ps_att_smd,
             survey_ps_ate_smd = survey_ps_ate_smd,
             survey_ps_att_smd = survey_ps_att_smd,
             ps_ate_sw_smd = ps_ate_sw_smd,
             ps_att_sw_smd = ps_att_sw_smd)

      return(a)
   }
   results[[scenario]]$ests <- do.call(rbind,ests.list)
}
# save results
save(results,nreps, file = "results.RData")
# stop the parallel processing cluter
stopCluster(cl)

##############################################################################
# generate summaries
ATE.ests <- c("survey_naive","atewt_surv","atewt_sw_surv","atewt_ps_surv",
              "survey_naive_t","atewt_surv_t","atewt_sw_surv_t",
              "atewt_ps_surv_t")
ATT.ests <- c("survey_naive","attwt_surv","attwt_sw_surv","attwt_ps_surv",
              "survey_naive_t","attwt_surv_t","attwt_sw_surv_t",
              "attwt_ps_surv_t")

ATE_BIAS <- sapply(results, function(x) {colMeans(x$ests[,ATE.ests] - x$ate)})
ATT_BIAS <- sapply(results, function(x) {colMeans(x$ests[,ATT.ests] - x$att)})
xtable(rbind(ATE_BIAS,ATT_BIAS))
round(rbind(ATE_BIAS,ATT_BIAS),3)

ATE.smd <- c("survey_naive_smd.1","ps_ate_smd.1","ps_ate_sw_smd.1",
             "survey_ps_ate_smd.1")
ATT.smd <- c("survey_naive_smd.1","ps_att_smd.1","ps_att_sw_smd.1",
             "survey_ps_att_smd.1")
ATE_SMD <- sapply(results, function(x) {colMeans(abs(x$ests[,ATE.smd]))})
ATT_SMD <- sapply(results, function(x) {colMeans(abs(x$ests[,ATT.smd]))})
xtable(rbind(ATE_SMD,ATT_SMD))

ATE_MSE <- sapply(results, function(x) {colMeans((x$ests[,ATE.ests] - x$ate)^2)})
ATT_MSE <- sapply(results, function(x) {colMeans((x$ests[,ATT.ests] - x$att)^2)})
xtable(sqrt(rbind(ATE_MSE,ATT_MSE)),digits=3)
round(sqrt(rbind(ATE_MSE,ATT_MSE)),3)

# check precision of RMSE
#   to make sure differences are not just simulation variation
mean((results[[1]]$ests[,"survey_naive"]-results[[1]]$ate)^2)
sd(  (results[[1]]$ests[,"survey_naive"]-results[[1]]$ate)^2)/
     sqrt(nrow(results[[1]]$ests))

ATE_MSE_SE <- 
   sapply(results, function(x) {apply((x$ests[,ATE.ests] - x$ate)^2,2,sd)})/
   sqrt(n.reps)
ATT_MSE_SE <- 
   sapply(results, function(x) {apply((x$ests[,ATT.ests] - x$att)^2,2,sd)})/
   sqrt(n.reps)

# delta method SE(RMSE)
ATE_MSE_SE/(2*sqrt(ATE_MSE))

lo <- ATE_MSE - 2*ATE_MSE_SE
hi <- ATE_MSE + 2*ATE_MSE_SE
lo[lo<0] <- hi[lo<0] <- NA
(sqrt(hi)-sqrt(lo))/2
