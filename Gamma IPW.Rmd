---
title: "Exploitation IPW-MSM"
output: html_notebook
---

# Setup

```{r}

load("/Users/SJP1/Dropbox/Gender economics/Exploitation IPW-MSM/PSID-Exploitation/Full_CleanedData.RData")
library(rio)
library(survey)
library(tidyverse)
library(geepack)
library(broom)
df <- as.data.frame(Full_CleanedData)

df <- df %>% mutate(Exploit35_cat = as.factor(ntile(Exploitation35, 10)),
              Sex = as.factor(Sex))

df <- df %>% 
  mutate(
    Exploitation35_0 = ifelse(Exploitation35 < quantile(Exploitation35, 0.1, na.rm = TRUE), quantile(Exploitation35, 0.1, na.rm = TRUE), Exploitation35),
  Exploitation35_0_L = lag(Exploitation35_0))

df <- as.data.frame(df)
```


# Confounder selection

```{r, eval=FALSE}
cs <- df %>% select(-contains("_L"), -contains("MI_TV"), -GenHealth_TV, -GenHealth.Base, -RelationToHead, -Individ.Weight, -SampErrClust_cume, -SampErrStrat_cume, -Sex_cume, -Year_cume, -K6_TV_cume, -RelationToHead_cume, -Age_cume, -Top_1_Percent_cume, -Exploitation40_cume, -Exploitation35_cume, - Extra.Job_TV,  -SpouseIncome, -Annual.OT.Hrs.Base, -Exploitation40,  -Individ.Weight_cume, -Exploit35_cat, -ID, -SampErrClust, -SampErrStrat, -K6_TV, -Top_1_Percent,  -DrLearnDisord.Base, -DrEmotProb.Base, -Exploitation35, -SMI_TV, -MMI_TV)

confounders <- names(cs)
exposure <- rep("Exploitation35 ~", length(confounders))
outcomes <- rep(c("MMI_TV ~", "SMI_TV ~"), each=length(confounders))

C_E <- Map(function(a,b) lm(as.formula(paste(list(a), paste(list(b), collapse="+"))), data=df), exposure, confounders )


C_E_df <- lapply(C_E, tidy)
C_E_df <- bind_rows(C_E_df)
NS_C_E_df <- C_E_df %>% filter(term != "(Intercept)", p.value > 0.05) 

not_sig <- df %>% select(-OT.Hrs.Main.Job, -N_Change_Industry_Base, -DrMemLoss.Base, -InterestIncome_TV, -ExtraJobIncome.Base, -OT.Income.Base, -OT.Hrs.Main.Job_cume, -SpouseIncome_cume, -SpouseIncome_TV_cume)

C_O <- Map(function(a,b) glm(as.formula(paste(list(a), paste(list(b), collapse="+"))), data=df, family="quasibinomial"), outcomes, confounders )

C_O_df <- lapply(C_O, tidy)
C_O_df <- bind_rows(C_O_df)
NS_C_O_df <- C_E_df %>% filter(term != "(Intercept)", p.value < 0.05) 

not_sig2 <- df %>% select(-OT.Hrs.Main.Job, -ExtraJobIncome.Base, -OT.Income.Base, -OT.Hrs.Main.Job_cume, -SpouseIncome_cume, -SpouseIncome_TV_cume)

```



```{r}

#vars_to_exclude <- unique(c("GenHealth_TV", "GenHealth.Base", "RelationToHead",  "SampErrClust_cume", "SampErrStrat_cume", "Sex_cume", "Year_cume", "K6_TV_cume", "RelationToHead_cume", "Age_cume", "Top_1_Percent_cume", "Exploitation40_cume", "Exploitation35_cume", "Extra.Job_TV", "SpouseIncome", "Annual.OT.Hrs.Base", "Exploitation40", "Individ.Weight_cume", "DrLearnDisord.Base", "DrEmotProb.Base", "Exploitation35",  "OT.Hrs.Main.Job", "N_Change_Industry_Base", "DrMemLoss.Base", "InterestIncome_TV", "ExtraJobIncome.Base", "OT.Income", "OT.Hrs.Main.Job_cume", "SpouseIncome_cume", "SpouseIncome_TV_cume", "OT.Hrs.Main.Job", "ExtraJobIncome.Base", "OT.Income.Base", "OT.Hrs.Main.Job_cume", "SpouseIncome_cume",  "SpouseIncome_TV_cume"))

library(dplyr)
df <- df %>%
  dplyr::select(-contains("GenHealth_TV"), -contains("GenHealth.Base"), -contains("RelationToHead"),  -contains("SampErrClust_cume"), -contains("SampErrStrat_cume"), -contains("Sex_cume"), -contains("Year_cume"), -contains("K6_TV_cume"), -contains("RelationToHead_cume"), -contains("Age_cume"), -contains("Top_1_Percent_cume"), -contains("Exploitation40_cume"), -contains("Exploitation35_cume"), -contains("Extra.Job_TV"),  -contains("Annual.OT.Hrs.Base"), -contains("Exploitation40"), -contains("Individ.Weight_cume"), -contains("DrLearnDisord.Base"), -contains("DrEmotProb.Base"),  -contains("OT.Hrs.Main.Job"), -contains("N_Change_Industry_Base"), -contains("DrMemLoss.Base"), -contains("InterestIncome_TV"), -contains("ExtraJobIncome.Base"), -contains("OT.Income.Base"), -contains("OT.Hrs.Main.Job_cume"), -contains("SpouseIncome_cume"), -contains("SpouseIncome_TV_cume"), -contains("OT.Hrs.Main.Job"), -contains("ExtraJobIncome.Base"), -contains("OT.Income.Base"), -contains("OT.Hrs.Main.Job_cume"), -contains("SpouseIncome_cume"),  -contains("SpouseIncome_TV_cume")) %>% 
  mutate_if(is.character, as.factor) %>% 
  mutate(Year = as.factor(Year))


df <- droplevels(df)

#options(survey.lonely.psu="average")
#svy_obj <- svydesign(ids = ~SampErrClust, strata = ~SampErrStrat, weights = ~Individ.Weight, nest = TRUE, data = df)

```

any disorder versus none
use the top 1% nationally rather then sample


# Quantile binning

## Choose variables for inverse probability of treament weights
```{r}

baseline_vars <- df %>% dplyr::select(contains("Base"), -OwnRent.Base, -KidHealth.Base, -Industry_Base)
baseline_vars <- c("Sex", "Race_cat", paste(names(baseline_vars), sep = ","))

time_var <- df %>% dplyr::select(contains("_L"), Year, -SpouseIncome, -Top_1_Percent_L, -K6_TV_L, -Age_L, -SpouseIncome_L, -SMI_TV_L, -MMI_TV_L,  -FamilyComp_cume_L, -TotalLaborIncome_TV_cume_L, -FamilySize_TV_cume_L, -Exploitation35_L, -WorkHrs_TV_L, -TotalLaborIncome_TV_L, -Industry_Cat_L)
time_var <- names(time_var)

baseline_vars_numer <- df %>% dplyr::select(contains("Base")) #, -Occupation_Base, -Industry_Base
baseline_vars_numer <- c("Sex", "Race_cat", paste(names(baseline_vars_numer), sep = ","))
```

## Create IP treatment weights 

```{r}

library(MASS)

denom.formula <- as.formula(c(paste("Exploitation35_0 ~ Exploitation35_0_L +"), paste(paste(baseline_vars, collapse = " + "), paste(time_var, collapse = " + "), sep = "+")))

denom.mod <- glm(denom.formula, data = df, weights = Individ.Weight, family=Gamma(link="log"))
summary(denom.mod)
x <- df$Exploitation35_0
  
scalex <- gamma.shape(denom.mod)$alpha
  
xb <- predict(denom.mod, type="response")
  
lambda= xb/scalex
  
denominator= dgamma(x, scale= lambda, shape=rep(scalex,100))


numer.formula <- as.formula(paste(paste("Exploitation35_0 ~ Exploitation35_L"), paste(baseline_vars_numer, collapse = " + "), sep = "+"))

numer.mod <- multinom(numer.formula, data = df, weights = Individ.Weight, MaxNWts = 6000, maxit = 2000)


pred.denom <- as.data.frame(predict(denom.mod, newdata = df, type = "prob"))
pred.numer <- as.data.frame(predict(numer.mod, newdata = df, type = "prob"))

df1 <- df %>%
  mutate(
    iptw.numerator = pred.numer[cbind(seq_len(nrow(pred.numer)), match(pred.numer$Exploit35_cat, colnames(pred.numer)))],
    iptw.denominator = pred.denom[cbind(seq_len(nrow(pred.denom)), match(pred.denom$Exploit35_cat, colnames(pred.denom)))],
    iptw = iptw.numerator / iptw.denominator,
    iptw.trunc = ifelse(iptw < quantile(iptw, 0.1, na.rm = TRUE), quantile(iptw, 0.1, na.rm = TRUE), ifelse(iptw > quantile(iptw, 0.99, na.rm = TRUE), quantile(iptw, 0.99, na.rm = TRUE), iptw))
  ) 


#quantile(df1$iptw.trunc, seq(0,1,.01), na.rm=TRUE)
#summary(df1$iptw.trunc)

#df1 %>% group_by(Year) %>% 
#  summarise(mean(iptw.trunc, na.rm=TRUE))

summary(df1$iptw.trunc)
```


## Choose variables for IP censoring weights

```{r}
df1 <- df1 %>% mutate(
  K6_censored = as.factor(as.numeric(is.na(K6_TV)))
)

Cens_df <- df1 %>% select(ID:Year, Age, Exploitation35, Exploit35_cat, contains("Base"), -contains("_L"), -contains("SMI"), -contains("MMI"), -K6_TV_L, -FamilyComp)

baseline_vars <- Cens_df %>% select(contains("Base"), -Yrs_Self_Emp_Base, -Yrs.Extra.Job_Base, -OwnRent.Base)
baseline_vars <- c("Sex", paste(names(baseline_vars), sep = ","))

time_var <- df1 %>% select(contains("_TV"), Exploitation35, Occupation_Cat, -contains("Base"), -contains("_L"), -contains("SMI"), -contains("MMI"), -contains("cume"),  -K6_TV, Year) 

time_var <- names(time_var)

 
```

## Create IP Censoring weights

```{r}

denom.formula.cens <- as.formula(c(paste("K6_censored ~ "), paste(paste(baseline_vars, collapse = " + "), paste(time_var, collapse = " + "), sep = "+")))

denom.mod.cens <- glm(denom.formula.cens, data = df1, weights = Individ.Weight, family = "quasibinomial", control = list(maxit = 50))

numer.formula.cens <- as.formula(c(paste(paste("K6_censored ~ "), paste(baseline_vars, collapse = " + "))))

numer.mod.cens <- glm(numer.formula.cens, data = df1, weights = Individ.Weight,  family = "quasibinomial", control = list(maxit = 50))

pred.denom.cen <- as.numeric(predict(denom.mod.cens, newdata = df1, type = "response"))
pred.numer.cen <- as.numeric(predict(numer.mod.cens, newdata = df1, type = "response"))
 
df2 <- df1 %>%
  mutate(ipcw = ifelse(df1$K6_censored == 0, ((1-pred.numer.cen)/(1-pred.denom.cen)), 1),
    ipcw = replace_na(ipcw, NA)
  )

```


## Multiply IPTW, censoring weights, and survey weights

```{r}

df2 <- df2 %>% mutate(ipw = iptw*ipcw*Individ.Weight)


df2 <- df2 %>% mutate(ipw = iptw*ipcw*Individ.Weight)
summary(df2$ipw)

```


# MSM

```{r}

df2 <- df2 %>% 
  filter(!is.na(ipw))

svy_obj <- svydesign(ids = ~SampErrClust, strata = ~SampErrStrat, weights = ~ipw, nest = TRUE, data = df2)


MSM <- svyglm(as.formula(c(paste(paste("MMI_TV ~ Exploitation35_L +"), paste(baseline_vars_numer, collapse = " + ")))), design = svy_obj, maxit=50 )

summary(MSM)
```




## Gamma model

```{r}



gammamod <- svyglm(Exploitation35 ~ Sex, family=Gamma(link="log"), svy_obj)
  
  x= yourdata$continuousexposure
  
  scalex= gamma.shape(gammamod)$alpha
  
  xb= predict(gammamod, type="response")
  
  lambda= xb/scalex
  
  denominator= dgamma(x, scale= lambda, shape=rep(scalex,100))
  
  gammamod2= glm(continuousexposure ~ 
                    time fixed confounder 1 
                  + time fixed confounder 2 
                  +  â€¦ 
                  + time fixed confounder N 
                    , data=yourdata, family=Gamma(link="log"))
  
  x2= yourdata$continuousexposure
  
  scalex2= gamma.shape(gammamod2)$alpha
   xb2= predict(gammamod2, type="response")
  lambda2= xb2/scalex2
  
  numerator= dgamma(x2, scale= lambda2, shape=rep(scalex2,100))
  weightgamma= numerator/denominator

  return(weightgamma)
}

```



## Debug

```{r}

debug_contr_error <- function (dat, subset_vec = NULL) {
  if (!is.null(subset_vec)) {
    ## step 0
    if (mode(subset_vec) == "logical") {
      if (length(subset_vec) != nrow(dat)) {
        stop("'logical' `subset_vec` provided but length does not match `nrow(dat)`")
        }
      subset_log_vec <- subset_vec
      } else if (mode(subset_vec) == "numeric") {
      ## check range
      ran <- range(subset_vec)
      if (ran[1] < 1 || ran[2] > nrow(dat)) {
        stop("'numeric' `subset_vec` provided but values are out of bound")
        } else {
        subset_log_vec <- logical(nrow(dat))
        subset_log_vec[as.integer(subset_vec)] <- TRUE
        } 
      } else {
      stop("`subset_vec` must be either 'logical' or 'numeric'")
      }
    dat <- base::subset(dat, subset = subset_log_vec)
    } else {
    ## step 1
    dat <- stats::na.omit(dat)
    }
  if (nrow(dat) == 0L) warning("no complete cases")
  ## step 2
  var_mode <- sapply(dat, mode)
  if (any(var_mode %in% c("complex", "raw"))) stop("complex or raw not allowed!")
  var_class <- sapply(dat, class)
  if (any(var_mode[var_class == "AsIs"] %in% c("logical", "character"))) {
    stop("matrix variables with 'AsIs' class must be 'numeric'")
    }
  ind1 <- which(var_mode %in% c("logical", "character"))
  dat[ind1] <- lapply(dat[ind1], as.factor)
  ## step 3
  fctr <- which(sapply(dat, is.factor))
  if (length(fctr) == 0L) warning("no factor variables to summary")
  ind2 <- if (length(ind1) > 0L) fctr[-ind1] else fctr
  dat[ind2] <- lapply(dat[ind2], base::droplevels.factor)
  ## step 4
  lev <- lapply(dat[fctr], base::levels.default)
  nl <- lengths(lev)
  ## return
  list(nlevels = nl, levels = lev)
}

debug_contr_error2 <- function (form, dat, subset_vec = NULL) {
  ## step 0
  if (!is.null(subset_vec)) {
    if (mode(subset_vec) == "logical") {
      if (length(subset_vec) != nrow(dat)) {
        stop("'logical' `subset_vec` provided but length does not match `nrow(dat)`")
        }
      subset_log_vec <- subset_vec
      } else if (mode(subset_vec) == "numeric") {
      ## check range
      ran <- range(subset_vec)
      if (ran[1] < 1 || ran[2] > nrow(dat)) {
        stop("'numeric' `subset_vec` provided but values are out of bound")
        } else {
        subset_log_vec <- logical(nrow(dat))
        subset_log_vec[as.integer(subset_vec)] <- TRUE
        } 
      } else {
      stop("`subset_vec` must be either 'logical' or 'numeric'")
      }
    dat <- base::subset(dat, subset = subset_log_vec)
    }
  ## step 0 and 1
  dat_internal <- stats::lm(form, data = dat, method = "model.frame")
  attr(dat_internal, "terms") <- NULL
  ## rely on `debug_contr_error` for steps 2 to 4
  c(list(mf = dat_internal), debug_contr_error(dat_internal, NULL))
}

debug_contr_error2(form=denom.formula, dat=df1)
```

 